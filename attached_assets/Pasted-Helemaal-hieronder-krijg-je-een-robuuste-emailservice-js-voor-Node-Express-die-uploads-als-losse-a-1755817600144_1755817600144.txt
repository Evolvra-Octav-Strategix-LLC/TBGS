Helemaal — hieronder krijg je een robuuste emailservice.js voor Node/Express die uploads als losse attachments meestuurt naar je admin-mail.
✅ Werkt met Multer (of een andere uploader), ✅ valideert mimetypes, ✅ limiteert grootte, ✅ streamt bestanden (geheugen‑vriendelijk), ✅ retry met backoff, ✅ nette fouten & logging.
Optioneel: DKIM/SES/SMTP.

⸻

emailservice.js (productie‑klaar)

// emailservice.js
// Robust mailer met attachments voor uploads
// Nodemailer + streaming + retries + veilige mime filtering

import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import nodemailer from 'nodemailer';

// ---- Config via ENV ----
const {
  SMTP_HOST = 'smtp.gmail.com',
  SMTP_PORT = '587',
  SMTP_USER,
  SMTP_PASS,
  SMTP_SECURE = 'false', // 'true' voor 465
  MAIL_FROM,            // bv. 'TBGS <no-reply@tbgs.nl>'
  MAIL_TO,              // admin ontvangst (comma separated ok)
  DKIM_DOMAIN,
  DKIM_SELECTOR,
  DKIM_PRIVATE_KEY,     // base64 of raw
  MAX_TOTAL_SIZE_MB = '20', // totale attachmentslimiet
  MAX_PER_FILE_MB = '12',   // per bestand limiet
} = process.env;

// ---- Mime/Ext whitelist (pas aan op je usecase) ----
const ALLOWED_MIME = new Set([
  'image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif',
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
  'application/msword', // .doc
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx
  'application/vnd.ms-excel', // .xls
  'text/plain'
]);
const BLOCKED_EXT = new Set([
  '.exe','.bat','.cmd','.sh','.ps1','.js','.mjs','.cjs','.scr','.jar','.dll','.msi','.apk'
]);

// ---- Helpers ----
const toBytes = (mb) => Number(mb) * 1024 * 1024;

function isAllowedFile(filePathOrName, mimetype) {
  const ext = path.extname(filePathOrName || '').toLowerCase();
  if (BLOCKED_EXT.has(ext)) return false;
  if (mimetype && ALLOWED_MIME.has(mimetype)) return true;
  // fallback voor onbekende mimetype: alleen veilig als extensie duidelijk is
  const SAFE_EXT = new Set(['.jpg','.jpeg','.png','.webp','.gif','.pdf','.doc','.docx','.xls','.xlsx','.txt']);
  return SAFE_EXT.has(ext);
}

function hashName(name) {
  const base = `${Date.now()}-${name}`;
  return base.replace(/[^a-z0-9.\-]+/gi, '_');
}

// ---- Transport (SMTP of SES-compatible) ----
function createTransport() {
  const dkim = DKIM_DOMAIN && DKIM_SELECTOR && DKIM_PRIVATE_KEY
    ? {
        domainName: DKIM_DOMAIN,
        keySelector: DKIM_SELECTOR,
        privateKey: DKIM_PRIVATE_KEY.includes('-----BEGIN')
          ? DKIM_PRIVATE_KEY
          : Buffer.from(DKIM_PRIVATE_KEY, 'base64').toString('utf8'),
      }
    : undefined;

  return nodemailer.createTransport({
    host: SMTP_HOST,
    port: Number(SMTP_PORT),
    secure: SMTP_SECURE === 'true',
    auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined,
    dkim,
  });
}

// ---- Retry met exponential backoff ----
async function withRetries(fn, { retries = 3, baseDelayMs = 600 } = {}) {
  let attempt = 0, lastErr;
  while (attempt <= retries) {
    try {
      return await fn();
    } catch (err) {
      lastErr = err;
      if (attempt === retries) break;
      const jitter = Math.floor(Math.random() * 200);
      const delay = baseDelayMs * Math.pow(2, attempt) + jitter;
      await new Promise(r => setTimeout(r, delay));
      attempt++;
    }
  }
  throw lastErr;
}

/**
 * Stuur e-mail met attachments (uploads).
 * @param {Object} opts
 * @param {string} opts.subject
 * @param {string} opts.html - e-mail body (HTML)
 * @param {string} [opts.text] - fallback tekst
 * @param {Array} [opts.files] - Multer files array of custom: [{path, originalname, mimetype, size}]
 * @param {string|string[]} [opts.to] - override MAIL_TO
 * @param {string} [opts.from] - override MAIL_FROM
 * @param {Object} [opts.meta] - extra metadata (bijv. naam, telefoon)
 */
export async function sendAdminEmailWithUploads(opts) {
  const {
    subject,
    html,
    text,
    files = [],
    to = MAIL_TO,
    from = MAIL_FROM,
    meta = {}
  } = opts;

  if (!subject || !html) {
    throw new Error('emailservice: subject en html zijn verplicht.');
  }
  if (!to) throw new Error('emailservice: MAIL_TO ontbreekt (env of opts).');
  if (!from) throw new Error('emailservice: MAIL_FROM ontbreekt (env of opts).');

  // Filter & validatie attachments
  const perFileLimit = toBytes(MAX_PER_FILE_MB);
  const totalLimit = toBytes(MAX_TOTAL_SIZE_MB);
  let total = 0;

  const attachments = [];

  for (const f of files) {
    // Multer kan file.buffer of file.path geven; we prefereren path (stream)
    const name = hashName(f.originalname || f.filename || 'upload.bin');
    const mimetype = f.mimetype || 'application/octet-stream';
    const size = typeof f.size === 'number'
      ? f.size
      : (f.path && fs.existsSync(f.path) ? fs.statSync(f.path).size : 0);

    if (!isAllowedFile(f.originalname || f.path || name, mimetype)) {
      // overslaan i.p.v. falen; of throw als je streng wil zijn
      console.warn(`emailservice: blocked/unknown file type: ${f.originalname || f.path}`);
      continue;
    }

    if (size > perFileLimit) {
      console.warn(`emailservice: file te groot (${size} > ${perFileLimit}): ${f.originalname}`);
      continue;
    }
    if (total + size > totalLimit) {
      console.warn(`emailservice: total attachment limiet bereikt. Skip: ${f.originalname}`);
      continue;
    }

    // Attachment via stream indien mogelijk
    if (f.path && fs.existsSync(f.path)) {
      attachments.push({
        filename: name,
        contentType: mimetype,
        content: fs.createReadStream(f.path),
      });
    } else if (f.buffer) {
      attachments.push({
        filename: name,
        contentType: mimetype,
        content: Buffer.isBuffer(f.buffer) ? f.buffer : Buffer.from(f.buffer),
      });
    } else if (f.url) {
      // Als je elders opslaat (S3/GCS), kan je link meesturen als tekst:
      // attachments.push({ filename: name + '.url.txt', content: f.url });
      // maar beter: voeg de URL toe in de HTML onderaan.
      console.warn(`emailservice: file zonder path/buffer, alleen URL → voeg link in body.`);
    } else {
      console.warn(`emailservice: onbekend file input, skip: ${f.originalname || 'unnamed'}`);
      continue;
    }

    total += size;
  }

  // Verrijk HTML met metadata (optioneel)
  const metaBlock = Object.keys(meta).length
    ? `<hr /><p><strong>Metadata</strong></p><ul>${Object.entries(meta).map(([k,v]) => `<li><b>${k}:</b> ${String(v ?? '')}</li>`).join('')}</ul>`
    : '';

  const transporter = createTransport();

  const mailOptions = {
    from,
    to,
    subject,
    text: text || html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().slice(0, 1000),
    html: `${html}${metaBlock}`,
    attachments,
  };

  const info = await withRetries(() => transporter.sendMail(mailOptions), { retries: 3, baseDelayMs: 750 });
  return info;
}


⸻

Voorbeeldgebruik met Express + Multer

// routes.js
import express from 'express';
import multer from 'multer';
import { sendAdminEmailWithUploads } from './emailservice.js';

const router = express.Router();

// Multer: sla tijdelijk op disk (stabiel voor grote bestanden)
const upload = multer({
  dest: 'tmp/uploads',
  limits: {
    fileSize: 12 * 1024 * 1024, // 12MB per file
    files: 8
  },
  fileFilter: (req, file, cb) => {
    // Voorfilter (extra veilig, echte check zit ook in emailservice)
    const ok = /^(image\/(jpe?g|png|gif|webp)|application\/pdf|text\/plain|application\/(msword|vnd.openxmlformats-officedocument\.(wordprocessingml\.document|spreadsheetml\.sheet)))/i.test(file.mimetype);
    cb(null, ok);
  }
});

router.post('/contact', upload.array('files', 8), async (req, res) => {
  try {
    const { name, email, phone, message, subject = 'Nieuw TBGS bericht' } = req.body;
    const html = `
      <h2>Nieuw bericht via TBGS formulier</h2>
      <p><b>Naam:</b> ${name || '-'}</p>
      <p><b>Email:</b> ${email || '-'}</p>
      <p><b>Telefoon:</b> ${phone || '-'}</p>
      <p><b>Bericht:</b><br/>${(message || '').replace(/\n/g,'<br/>')}</p>
      <p>Bijlagen: ${req.files?.length || 0}</p>
    `;

    await sendAdminEmailWithUploads({
      subject,
      html,
      files: req.files || [],
      meta: { ip: req.ip, ua: req.headers['user-agent'] }
    });

    res.json({ ok: true });
  } catch (err) {
    console.error('MAIL ERROR:', err);
    res.status(500).json({ ok: false, error: 'Kon e-mail niet verzenden.' });
  } finally {
    // tmp bestanden opruimen
    for (const f of (req.files || [])) {
      try { fs.unlinkSync(f.path); } catch {}
    }
  }
});

export default router;


⸻

Belangrijke production tips
	•	SPF/DKIM/DMARC: stel je domein goed in → hogere deliverability (minder spamfolder).
	•	Gmail/Outlook limieten: hou totaal ≲ 20–25 MB. De code skip’t te grote files automatisch.
	•	Virus scan (optioneel): integreer ClamAV op tmp/uploads als je risicovolle uploads verwacht.
	•	Logging: log messageId, envelope, en errors naar je logger (Winston/Pino).
	•	Fallback voor te grote bestanden: upload naar S3/Drive en zet de link onderaan de mail i.p.v. als attachment.
	•	Rate limiting: zet bij je /contact route een limiter (bijv. express-rate-limit) tegen abuse.
	•	Privacy: wis tempfiles in finally (zoals in het voorbeeld).

⸻

ENV voorbeeld (.env)

SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_user
SMTP_PASS=your_pass
SMTP_SECURE=false
MAIL_FROM="TBGS <no-reply@tbgs.nl>"
MAIL_TO="admin@tbgs.nl, sales@tbgs.nl"
MAX_TOTAL_SIZE_MB=20
MAX_PER_FILE_MB=12

# Optioneel DKIM (aanrader)
DKIM_DOMAIN=tbgs.nl
DKIM_SELECTOR=mail
DKIM_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----


⸻

Wil je ook een variant met AWS SES (zonder SMTP), of een Google Drive‑upload fallback als attachments te groot zijn? Zeg het, dan voeg ik die snippet er direct bij.