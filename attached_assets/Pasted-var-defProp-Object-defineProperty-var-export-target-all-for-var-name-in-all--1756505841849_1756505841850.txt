var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  adminUsers: () => adminUsers,
  articleTags: () => articleTags,
  articleTagsRelations: () => articleTagsRelations,
  articles: () => articles,
  articlesRelations: () => articlesRelations,
  categories: () => categories,
  categoriesRelations: () => categoriesRelations,
  insertAdminUserSchema: () => insertAdminUserSchema,
  insertArticleSchema: () => insertArticleSchema,
  insertCategorySchema: () => insertCategorySchema,
  insertServiceRequestSchema: () => insertServiceRequestSchema,
  insertTagSchema: () => insertTagSchema,
  insertUserSchema: () => insertUserSchema,
  serviceRequests: () => serviceRequests,
  tags: () => tags,
  tagsRelations: () => tagsRelations,
  users: () => users
});
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, json } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
var users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  username: text("username").notNull().unique(),
  password: text("password").notNull()
});
var serviceRequests = pgTable("service_requests", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  selectedService: text("selected_service").notNull(),
  photos: json("photos").$type().default([]),
  address: text("address").notNull(),
  projectDescription: text("project_description").notNull(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  contactPreference: text("contact_preference").notNull(),
  submittedAt: timestamp("submitted_at").defaultNow()
});
var categories = pgTable("categories", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull().unique(),
  slug: text("slug").notNull().unique(),
  description: text("description"),
  color: text("color").notNull().default("#3b82f6"),
  // Blue default
  createdAt: timestamp("created_at").defaultNow()
});
var tags = pgTable("tags", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull().unique(),
  slug: text("slug").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow()
});
var articles = pgTable("articles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  slug: text("slug").notNull().unique(),
  excerpt: text("excerpt"),
  content: text("content").notNull(),
  metaTitle: text("meta_title"),
  metaDescription: text("meta_description"),
  keywords: text("keywords"),
  featuredImage: text("featured_image"),
  categoryId: varchar("category_id").references(() => categories.id),
  status: text("status").notNull().default("draft"),
  // draft, published
  publishedAt: timestamp("published_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var articleTags = pgTable("article_tags", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  articleId: varchar("article_id").notNull().references(() => articles.id, { onDelete: "cascade" }),
  tagId: varchar("tag_id").notNull().references(() => tags.id, { onDelete: "cascade" })
});
var adminUsers = pgTable("admin_users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  name: text("name").notNull(),
  role: text("role").notNull().default("admin"),
  createdAt: timestamp("created_at").defaultNow()
});
var categoriesRelations = relations(categories, ({ many }) => ({
  articles: many(articles)
}));
var articlesRelations = relations(articles, ({ one, many }) => ({
  category: one(categories, {
    fields: [articles.categoryId],
    references: [categories.id]
  }),
  articleTags: many(articleTags)
}));
var tagsRelations = relations(tags, ({ many }) => ({
  articleTags: many(articleTags)
}));
var articleTagsRelations = relations(articleTags, ({ one }) => ({
  article: one(articles, {
    fields: [articleTags.articleId],
    references: [articles.id]
  }),
  tag: one(tags, {
    fields: [articleTags.tagId],
    references: [tags.id]
  })
}));
var insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true
});
var insertServiceRequestSchema = createInsertSchema(serviceRequests).pick({
  selectedService: true,
  photos: true,
  address: true,
  projectDescription: true,
  firstName: true,
  lastName: true,
  email: true,
  phone: true,
  contactPreference: true
});
var insertCategorySchema = createInsertSchema(categories).omit({
  id: true,
  createdAt: true
});
var insertTagSchema = createInsertSchema(tags).omit({
  id: true,
  createdAt: true
});
var insertArticleSchema = createInsertSchema(articles).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var insertAdminUserSchema = createInsertSchema(adminUsers).omit({
  id: true,
  createdAt: true
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({ connectionString: process.env.DATABASE_URL });
var db = drizzle({ client: pool, schema: schema_exports });

// server/storage.ts
import { eq, desc, like, and, or } from "drizzle-orm";
var DatabaseStorage = class {
  // Users
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }
  async createUser(insertUser) {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }
  // Admin Users
  async getAdminUser(id) {
    const [user] = await db.select().from(adminUsers).where(eq(adminUsers.id, id));
    return user;
  }
  async getAdminUserByEmail(email) {
    const [user] = await db.select().from(adminUsers).where(eq(adminUsers.email, email));
    return user;
  }
  async createAdminUser(insertUser) {
    const [user] = await db.insert(adminUsers).values(insertUser).returning();
    return user;
  }
  // Categories
  async getCategories() {
    return db.select().from(categories).orderBy(categories.name);
  }
  async getCategoryBySlug(slug) {
    const [category] = await db.select().from(categories).where(eq(categories.slug, slug));
    return category;
  }
  async createCategory(insertCategory) {
    const [category] = await db.insert(categories).values(insertCategory).returning();
    return category;
  }
  async updateCategory(id, updateData) {
    const [category] = await db.update(categories).set(updateData).where(eq(categories.id, id)).returning();
    return category;
  }
  async deleteCategory(id) {
    const result = await db.delete(categories).where(eq(categories.id, id));
    return (result.rowCount || 0) > 0;
  }
  // Tags
  async getTags() {
    return db.select().from(tags).orderBy(tags.name);
  }
  async getTagBySlug(slug) {
    const [tag] = await db.select().from(tags).where(eq(tags.slug, slug));
    return tag;
  }
  async createTag(insertTag) {
    const [tag] = await db.insert(tags).values(insertTag).returning();
    return tag;
  }
  async updateTag(id, updateData) {
    const [tag] = await db.update(tags).set(updateData).where(eq(tags.id, id)).returning();
    return tag;
  }
  async deleteTag(id) {
    const result = await db.delete(tags).where(eq(tags.id, id));
    return (result.rowCount || 0) > 0;
  }
  // Articles
  async getArticles(filters) {
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(articles.status, filters.status));
    }
    if (filters?.categoryId) {
      conditions.push(eq(articles.categoryId, filters.categoryId));
    }
    if (filters?.search) {
      conditions.push(
        or(
          like(articles.title, `%${filters.search}%`),
          like(articles.content, `%${filters.search}%`)
        )
      );
    }
    if (conditions.length > 0) {
      return db.select().from(articles).where(and(...conditions)).orderBy(desc(articles.updatedAt));
    }
    return db.select().from(articles).orderBy(desc(articles.updatedAt));
  }
  async getArticle(id) {
    const [article] = await db.select().from(articles).where(eq(articles.id, id));
    return article;
  }
  async getArticleBySlug(slug) {
    const [article] = await db.select().from(articles).where(eq(articles.slug, slug));
    return article;
  }
  async getPublishedArticles() {
    return db.select().from(articles).where(eq(articles.status, "published")).orderBy(desc(articles.publishedAt));
  }
  async createArticle(insertArticle) {
    const [article] = await db.insert(articles).values(insertArticle).returning();
    return article;
  }
  async updateArticle(id, updateData) {
    const updatedData = {
      ...updateData,
      updatedAt: /* @__PURE__ */ new Date()
    };
    const [article] = await db.update(articles).set(updatedData).where(eq(articles.id, id)).returning();
    return article;
  }
  async deleteArticle(id) {
    const result = await db.delete(articles).where(eq(articles.id, id));
    return (result.rowCount || 0) > 0;
  }
  // Article Tags
  async getArticleTags(articleId) {
    const result = await db.select({
      id: tags.id,
      name: tags.name,
      slug: tags.slug,
      createdAt: tags.createdAt
    }).from(articleTags).innerJoin(tags, eq(articleTags.tagId, tags.id)).where(eq(articleTags.articleId, articleId));
    return result;
  }
  async setArticleTags(articleId, tagIds) {
    await db.delete(articleTags).where(eq(articleTags.articleId, articleId));
    if (tagIds.length > 0) {
      const tagData = tagIds.map((tagId) => ({ articleId, tagId }));
      await db.insert(articleTags).values(tagData);
    }
  }
  // Service Requests (existing functionality)
  async getServiceRequests() {
    return db.select().from(serviceRequests).orderBy(desc(serviceRequests.submittedAt));
  }
  async createServiceRequest(insertRequest) {
    const [request] = await db.insert(serviceRequests).values([insertRequest]).returning();
    return request;
  }
};
var storage = new DatabaseStorage();

// server/routes.ts
import { z } from "zod";

// server/objectStorage.ts
import { Storage } from "@google-cloud/storage";
import { randomUUID } from "crypto";

// server/objectAcl.ts
var ACL_POLICY_METADATA_KEY = "custom:aclPolicy";
function isPermissionAllowed(requested, granted) {
  if (requested === "read" /* READ */) {
    return ["read" /* READ */, "write" /* WRITE */].includes(granted);
  }
  return granted === "write" /* WRITE */;
}
function createObjectAccessGroup(group) {
  switch (group.type) {
    // Implement the case for each type of access group to instantiate.
    //
    // For example:
    // case "USER_LIST":
    //   return new UserListAccessGroup(group.id);
    // case "EMAIL_DOMAIN":
    //   return new EmailDomainAccessGroup(group.id);
    // case "GROUP_MEMBER":
    //   return new GroupMemberAccessGroup(group.id);
    // case "SUBSCRIBER":
    //   return new SubscriberAccessGroup(group.id);
    default:
      throw new Error(`Unknown access group type: ${group.type}`);
  }
}
async function setObjectAclPolicy(objectFile, aclPolicy) {
  const [exists] = await objectFile.exists();
  if (!exists) {
    throw new Error(`Object not found: ${objectFile.name}`);
  }
  await objectFile.setMetadata({
    metadata: {
      [ACL_POLICY_METADATA_KEY]: JSON.stringify(aclPolicy)
    }
  });
}
async function getObjectAclPolicy(objectFile) {
  const [metadata] = await objectFile.getMetadata();
  const aclPolicy = metadata?.metadata?.[ACL_POLICY_METADATA_KEY];
  if (!aclPolicy) {
    return null;
  }
  return JSON.parse(aclPolicy);
}
async function canAccessObject({
  userId,
  objectFile,
  requestedPermission
}) {
  const aclPolicy = await getObjectAclPolicy(objectFile);
  if (!aclPolicy) {
    return false;
  }
  if (aclPolicy.visibility === "public" && requestedPermission === "read" /* READ */) {
    return true;
  }
  if (!userId) {
    return false;
  }
  if (aclPolicy.owner === userId) {
    return true;
  }
  for (const rule of aclPolicy.aclRules || []) {
    const accessGroup = createObjectAccessGroup(rule.group);
    if (await accessGroup.hasMember(userId) && isPermissionAllowed(requestedPermission, rule.permission)) {
      return true;
    }
  }
  return false;
}

// server/objectStorage.ts
var REPLIT_SIDECAR_ENDPOINT = "http://127.0.0.1:1106";
var objectStorageClient = new Storage({
  credentials: {
    audience: "replit",
    subject_token_type: "access_token",
    token_url: `${REPLIT_SIDECAR_ENDPOINT}/token`,
    type: "external_account",
    credential_source: {
      url: `${REPLIT_SIDECAR_ENDPOINT}/credential`,
      format: {
        type: "json",
        subject_token_field_name: "access_token"
      }
    },
    universe_domain: "googleapis.com"
  },
  projectId: ""
});
var ObjectNotFoundError = class _ObjectNotFoundError extends Error {
  constructor() {
    super("Object not found");
    this.name = "ObjectNotFoundError";
    Object.setPrototypeOf(this, _ObjectNotFoundError.prototype);
  }
};
var ObjectStorageService = class {
  constructor() {
  }
  // Gets the public object search paths.
  getPublicObjectSearchPaths() {
    const pathsStr = process.env.PUBLIC_OBJECT_SEARCH_PATHS || "";
    const paths = Array.from(
      new Set(
        pathsStr.split(",").map((path5) => path5.trim()).filter((path5) => path5.length > 0)
      )
    );
    if (paths.length === 0) {
      throw new Error(
        "PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' tool and set PUBLIC_OBJECT_SEARCH_PATHS env var (comma-separated paths)."
      );
    }
    return paths;
  }
  // Gets the private object directory.
  getPrivateObjectDir() {
    const dir = process.env.PRIVATE_OBJECT_DIR || "";
    if (!dir) {
      throw new Error(
        "PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' tool and set PRIVATE_OBJECT_DIR env var."
      );
    }
    return dir;
  }
  // Search for a public object from the search paths.
  async searchPublicObject(filePath) {
    for (const searchPath of this.getPublicObjectSearchPaths()) {
      const fullPath = `${searchPath}/${filePath}`;
      const { bucketName, objectName } = parseObjectPath(fullPath);
      const bucket = objectStorageClient.bucket(bucketName);
      const file = bucket.file(objectName);
      const [exists] = await file.exists();
      if (exists) {
        return file;
      }
    }
    return null;
  }
  // Downloads an object to the response.
  async downloadObject(file, res, cacheTtlSec = 3600) {
    try {
      const [metadata] = await file.getMetadata();
      const aclPolicy = await getObjectAclPolicy(file);
      const isPublic = aclPolicy?.visibility === "public";
      res.set({
        "Content-Type": metadata.contentType || "application/octet-stream",
        "Content-Length": metadata.size,
        "Cache-Control": `${isPublic ? "public" : "private"}, max-age=${cacheTtlSec}`
      });
      const stream = file.createReadStream();
      stream.on("error", (err) => {
        console.error("Stream error:", err);
        if (!res.headersSent) {
          res.status(500).json({ error: "Error streaming file" });
        }
      });
      stream.pipe(res);
    } catch (error) {
      console.error("Error downloading file:", error);
      if (!res.headersSent) {
        res.status(500).json({ error: "Error downloading file" });
      }
    }
  }
  // Gets the upload URL for an object entity.
  async getObjectEntityUploadURL() {
    const privateObjectDir = this.getPrivateObjectDir();
    if (!privateObjectDir) {
      throw new Error(
        "PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' tool and set PRIVATE_OBJECT_DIR env var."
      );
    }
    const objectId = randomUUID();
    const fullPath = `${privateObjectDir}/uploads/${objectId}`;
    const { bucketName, objectName } = parseObjectPath(fullPath);
    return signObjectURL({
      bucketName,
      objectName,
      method: "PUT",
      ttlSec: 1800
      // 30 minutes for large file uploads
    });
  }
  // Get multiple upload URLs for batch processing
  async getBatchUploadURLs(count = 5) {
    const privateObjectDir = this.getPrivateObjectDir();
    if (!privateObjectDir) {
      throw new Error(
        "PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' tool and set PRIVATE_OBJECT_DIR env var."
      );
    }
    const urls = [];
    const promises = Array.from({ length: count }, async () => {
      const objectId = randomUUID();
      const fullPath = `${privateObjectDir}/uploads/${objectId}`;
      const { bucketName, objectName } = parseObjectPath(fullPath);
      return signObjectURL({
        bucketName,
        objectName,
        method: "PUT",
        ttlSec: 1800
      });
    });
    return Promise.all(promises);
  }
  // Gets the object entity file from the object path.
  async getObjectEntityFile(objectPath) {
    if (!objectPath.startsWith("/objects/")) {
      throw new ObjectNotFoundError();
    }
    const parts = objectPath.slice(1).split("/");
    if (parts.length < 2) {
      throw new ObjectNotFoundError();
    }
    const entityId = parts.slice(1).join("/");
    let entityDir = this.getPrivateObjectDir();
    if (!entityDir.endsWith("/")) {
      entityDir = `${entityDir}/`;
    }
    const objectEntityPath = `${entityDir}${entityId}`;
    const { bucketName, objectName } = parseObjectPath(objectEntityPath);
    const bucket = objectStorageClient.bucket(bucketName);
    const objectFile = bucket.file(objectName);
    const [exists] = await objectFile.exists();
    if (!exists) {
      throw new ObjectNotFoundError();
    }
    return objectFile;
  }
  normalizeObjectEntityPath(rawPath) {
    if (!rawPath.startsWith("https://storage.googleapis.com/")) {
      return rawPath;
    }
    const url = new URL(rawPath);
    const rawObjectPath = url.pathname;
    let objectEntityDir = this.getPrivateObjectDir();
    if (!objectEntityDir.endsWith("/")) {
      objectEntityDir = `${objectEntityDir}/`;
    }
    if (!rawObjectPath.startsWith(objectEntityDir)) {
      return rawObjectPath;
    }
    const entityId = rawObjectPath.slice(objectEntityDir.length);
    return `/objects/${entityId}`;
  }
  // Tries to set the ACL policy for the object entity and return the normalized path.
  async trySetObjectEntityAclPolicy(rawPath, aclPolicy) {
    const normalizedPath = this.normalizeObjectEntityPath(rawPath);
    if (!normalizedPath.startsWith("/")) {
      return normalizedPath;
    }
    const objectFile = await this.getObjectEntityFile(normalizedPath);
    await setObjectAclPolicy(objectFile, aclPolicy);
    return normalizedPath;
  }
  // Checks if the user can access the object entity.
  async canAccessObjectEntity({
    userId,
    objectFile,
    requestedPermission
  }) {
    return canAccessObject({
      userId,
      objectFile,
      requestedPermission: requestedPermission ?? "read" /* READ */
    });
  }
};
function parseObjectPath(path5) {
  if (!path5.startsWith("/")) {
    path5 = `/${path5}`;
  }
  const pathParts = path5.split("/");
  if (pathParts.length < 3) {
    throw new Error("Invalid path: must contain at least a bucket name");
  }
  const bucketName = pathParts[1];
  const objectName = pathParts.slice(2).join("/");
  return {
    bucketName,
    objectName
  };
}
async function signObjectURL({
  bucketName,
  objectName,
  method,
  ttlSec
}) {
  const request = {
    bucket_name: bucketName,
    object_name: objectName,
    method,
    expires_at: new Date(Date.now() + ttlSec * 1e3).toISOString()
  };
  const response = await fetch(
    `${REPLIT_SIDECAR_ENDPOINT}/object-storage/signed-object-url`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(request)
    }
  );
  if (!response.ok) {
    throw new Error(
      `Failed to sign object URL, errorcode: ${response.status}, make sure you're running on Replit`
    );
  }
  const { signed_url: signedURL } = await response.json();
  return signedURL;
}

// server/emailService.ts
import nodemailer from "nodemailer";
import fs2 from "fs";
import path2 from "path";

// server/vcard.ts
import crypto from "crypto";
import fs from "fs";
import path from "path";
function esc(s = "") {
  return String(s).replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/;/g, "\\;").replace(/,/g, "\\,");
}
function fold(line) {
  const bytes = Buffer.from(line, "utf8");
  if (bytes.length <= 73) return line;
  let out = "";
  let i = 0;
  while (i < bytes.length) {
    const take = Math.min(73, bytes.length - i);
    out += Buffer.from(bytes.slice(i, i + take)).toString("utf8");
    i += take;
    if (i < bytes.length) out += "\r\n ";
  }
  return out;
}
function getLogoBase64() {
  try {
    const tbgsPaths = [
      path.join(process.cwd(), "attached_assets", "TBGS 545x642_1754928031668.png"),
      path.join(process.cwd(), "attached_assets", "TBGS 545x642_1754935666047.png"),
      path.join(process.cwd(), "attached_assets", "TBGS 545x642_1754935848756.png")
    ];
    for (const logoPath of tbgsPaths) {
      if (fs.existsSync(logoPath)) {
        const logoBuffer = fs.readFileSync(logoPath);
        console.log(`\u2713 TBGS logo loaded for vCard: ${path.basename(logoPath)}`);
        return logoBuffer.toString("base64");
      }
    }
    console.warn("vCard: TBGS logo bestanden niet gevonden voor profile photo");
    return null;
  } catch (error) {
    console.error("vCard: Error loading TBGS logo:", error);
    return null;
  }
}
function createVCard(c) {
  const now = (/* @__PURE__ */ new Date()).toISOString().replace(/[-:]/g, "").replace(/\.\d+Z$/, "Z");
  const uid = crypto.randomUUID?.() ?? crypto.randomBytes(16).toString("hex");
  const fullName = c.fullName || [c.givenName, c.familyName].filter(Boolean).join(" ").trim() || c.org || "TBGS Contact";
  const n = `${esc(c.familyName || "")};${esc(c.givenName || "")};;;`;
  const fn = esc(fullName);
  const org = esc(c.org || "TBGS B.V. - Totaal Bouw Groep Specialisten");
  const title = esc(c.title || "Specialist");
  const email = esc(c.email || "");
  const phone = esc(c.phone || "");
  const mobile = esc(c.mobile || "");
  const url = esc(c.url || "");
  const notes = esc(c.notes || "");
  const street = esc(c.street || "");
  const city = esc(c.city || "");
  const region = esc(c.region || "");
  const postcode = esc(c.postcode || "");
  const country = esc(c.country || "");
  const adr = `;;${street};${city};${region};${postcode};${country}`;
  const addressForMaps = [street, city, region, postcode, country].filter(Boolean).join(", ");
  const mapsUrl = addressForMaps ? `https://maps.google.com/maps?q=${encodeURIComponent(addressForMaps)}` : "";
  const lines = [
    "BEGIN:VCARD",
    "VERSION:3.0",
    fold(`N:${n}`),
    fold(`FN:${fn}`),
    fold(`ORG:${org}`),
    title ? fold(`TITLE:${title}`) : "",
    email ? fold(`EMAIL;TYPE=INTERNET,PREF:${email}`) : "",
    phone ? fold(`TEL;TYPE=WORK,VOICE:${phone}`) : "",
    mobile ? fold(`TEL;TYPE=CELL,VOICE:${mobile}`) : "",
    street || city || region || postcode || country ? fold(`ADR;TYPE=WORK:${adr}`) : "",
    url ? fold(`URL:${url}`) : "",
    mapsUrl ? fold(`URL;TYPE=MAPS:${mapsUrl}`) : "",
    // Google Maps link
    notes ? fold(`NOTE:${notes}`) : "",
    `REV:${now}`,
    `UID:${uid}`
  ];
  const logoBase64 = getLogoBase64();
  if (logoBase64) {
    const photoLine = `PHOTO;ENCODING=BASE64;TYPE=PNG:${logoBase64}`;
    lines.splice(-2, 0, fold(photoLine));
  }
  lines.push("END:VCARD");
  const vcf = lines.filter(Boolean).join("\r\n") + "\r\n";
  return Buffer.from(vcf, "utf8");
}
function createTBGSVCard(formData) {
  let street = formData.street || "";
  let city = formData.city || "";
  let postcode = formData.postcode || "";
  let houseNumber = formData.houseNumber || "";
  let country = formData.country || "Nederland";
  if (!street && !city && !postcode && formData.address) {
    const fullAddress = formData.address.trim();
    const dutchMatch = fullAddress.match(/^(.+?\s+\d+.*?),\s*(\d{4}\s*[A-Za-z]{2})\s+(.+)$/);
    if (dutchMatch) {
      const streetWithNumber = dutchMatch[1].trim();
      postcode = dutchMatch[2].trim();
      city = dutchMatch[3].trim();
      country = "Nederland";
      const streetNumberMatch = streetWithNumber.match(/^(.+?)\s+(\d+.*?)$/);
      if (streetNumberMatch) {
        street = streetNumberMatch[1];
        houseNumber = streetNumberMatch[2];
      } else {
        street = streetWithNumber;
      }
    } else {
      const belgianMatch = fullAddress.match(/^(.+?\s+\d+.*?),\s*(\d{4})\s+(.+)$/);
      if (belgianMatch) {
        const streetWithNumber = belgianMatch[1].trim();
        postcode = belgianMatch[2].trim();
        city = belgianMatch[3].trim();
        country = "Belgi\xEB";
        const streetNumberMatch = streetWithNumber.match(/^(.+?)\s+(\d+.*?)$/);
        if (streetNumberMatch) {
          street = streetNumberMatch[1];
          houseNumber = streetNumberMatch[2];
        } else {
          street = streetWithNumber;
        }
      } else {
        const addressParts = fullAddress.split(",").map((p) => p.trim());
        if (addressParts.length >= 2) {
          const streetPart = addressParts[0];
          const streetMatch = streetPart.match(/^(.+?)\s+(\d+.*?)$/);
          if (streetMatch) {
            street = streetMatch[1];
            houseNumber = streetMatch[2];
          } else {
            street = streetPart;
          }
          const lastPart = addressParts[addressParts.length - 1];
          const dutchPostcodeMatch = lastPart.match(/(\d{4}\s*[A-Za-z]{2})/);
          if (dutchPostcodeMatch) {
            postcode = dutchPostcodeMatch[1];
            city = lastPart.replace(dutchPostcodeMatch[0], "").trim();
            country = "Nederland";
          } else {
            const belgianPostcodeMatch = lastPart.match(/(\d{4})/);
            if (belgianPostcodeMatch) {
              postcode = belgianPostcodeMatch[1];
              city = lastPart.replace(belgianPostcodeMatch[0], "").trim();
              country = "Belgi\xEB";
            } else {
              city = lastPart;
            }
          }
        } else {
          street = fullAddress;
        }
      }
    }
  }
  let notes = "";
  if (formData.firstName || formData.lastName) {
    const fullName = [formData.firstName, formData.lastName].filter(Boolean).join(" ");
    notes += `Contactpersoon: ${fullName}
`;
  }
  if (formData.email) {
    notes += `Email: ${formData.email}
`;
  }
  if (formData.phone) {
    notes += `Telefoon: ${formData.phone}
`;
  }
  const cleanCity = city.replace(/,?\s*(Nederland|Belgium|België)\s*$/i, "").trim();
  const addressDetails = [street, houseNumber, postcode, cleanCity].filter(Boolean);
  if (addressDetails.length > 0) {
    notes += `Adres: ${addressDetails.join(" ")}
`;
  }
  if (country) {
    notes += `Land: ${country}
`;
  }
  if (formData.selectedService) {
    notes += `
Gewenste service: ${formData.selectedService}
`;
  }
  if (formData.projectDescription) {
    notes += `Projectomschrijving: ${formData.projectDescription}
`;
  }
  notes += `
--- TBGS B.V. ---
Contactverzoek ontvangen via website
Specialisten in dak-, schoorsteen- en onderhoudswerkzaamheden`;
  if (notes.length === 0) {
    notes = "TBGS B.V. - Contactverzoek via website";
  }
  const namePart = [formData.firstName, formData.lastName].filter(Boolean).join(" ");
  const addressPart = [street, houseNumber].filter(Boolean).join(" ");
  const locationPart = [postcode, cleanCity].filter(Boolean).join(" ");
  const displayParts = [namePart, addressPart, locationPart].filter(Boolean);
  const fullDisplayName = displayParts.join(", ");
  let region = "";
  if (country === "Nederland") {
    region = "Noord-Brabant";
  } else if (country === "Belgi\xEB") {
    region = "";
  }
  return createVCard({
    givenName: fullDisplayName,
    // Full info in firstname for WhatsApp: naam, adres, postcode stad (NO country)
    familyName: "",
    // Keep lastname empty to avoid duplication
    fullName: fullDisplayName,
    email: formData.email,
    mobile: formData.phone ? formData.phone : void 0,
    // Only add if client provided
    phone: void 0,
    // No work number unless provided
    street: [street, houseNumber].filter(Boolean).join(" "),
    // Complete street address: Hurkssestraat 64
    city: cleanCity,
    // Clean city without country: Eindhoven/Antwerpen
    postcode,
    // Exact postcode: 5652 AH / 2000
    country,
    // Nederland or België - separate field
    region,
    // Province/region based on country
    org: "TBGS B.V.",
    title: [street, houseNumber, postcode, cleanCity].filter(Boolean).join(" "),
    // Clean address in title: straatnaam huisnummer postcode stad (NO country)
    url: void 0,
    // Remove homepage URL
    notes
  });
}

// server/emailService.ts
var {
  SMTP_HOST = "smtp.gmail.com",
  SMTP_PORT = "587",
  SMTP_USER = process.env.GMAIL_USER,
  SMTP_PASS = process.env.GMAIL_APP_PASSWORD,
  SMTP_SECURE = "false",
  // 'true' voor 465
  MAIL_FROM = process.env.GMAIL_USER,
  MAIL_TO = process.env.GMAIL_USER,
  // admin ontvangst
  MAX_TOTAL_SIZE_MB = "20",
  // totale attachmentslimiet
  MAX_PER_FILE_MB = "12"
  // per bestand limiet
} = process.env;
var ALLOWED_MIME = /* @__PURE__ */ new Set([
  "image/jpeg",
  "image/jpg",
  "image/png",
  "image/webp",
  "image/gif",
  "application/pdf",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  // .docx
  "application/msword",
  // .doc
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  // .xlsx
  "application/vnd.ms-excel",
  // .xls
  "text/plain"
]);
var BLOCKED_EXT = /* @__PURE__ */ new Set([
  ".exe",
  ".bat",
  ".cmd",
  ".sh",
  ".ps1",
  ".js",
  ".mjs",
  ".cjs",
  ".scr",
  ".jar",
  ".dll",
  ".msi",
  ".apk"
]);
var toBytes = (mb) => Number(mb) * 1024 * 1024;
function isAllowedFile(filePathOrName, mimetype) {
  const ext = path2.extname(filePathOrName || "").toLowerCase();
  if (BLOCKED_EXT.has(ext)) return false;
  if (mimetype && ALLOWED_MIME.has(mimetype)) return true;
  const SAFE_EXT = /* @__PURE__ */ new Set([".jpg", ".jpeg", ".png", ".webp", ".gif", ".pdf", ".doc", ".docx", ".xls", ".xlsx", ".txt"]);
  return SAFE_EXT.has(ext);
}
function hashName(name) {
  const base = `${Date.now()}-${name}`;
  return base.replace(/[^a-z0-9.\-]+/gi, "_");
}
async function withRetries(fn, { retries = 3, baseDelayMs = 600 } = {}) {
  let attempt = 0;
  let lastErr;
  while (attempt <= retries) {
    try {
      return await fn();
    } catch (err) {
      lastErr = err;
      if (attempt === retries) break;
      const jitter = Math.floor(Math.random() * 200);
      const delay = baseDelayMs * Math.pow(2, attempt) + jitter;
      await new Promise((r) => setTimeout(r, delay));
      attempt++;
    }
  }
  throw lastErr;
}
var EmailService = class {
  transporter = null;
  async getTransporter() {
    if (!this.transporter) {
      this.transporter = nodemailer.createTransport({
        host: SMTP_HOST,
        port: Number(SMTP_PORT),
        secure: SMTP_SECURE === "true",
        auth: SMTP_USER && SMTP_PASS ? {
          user: SMTP_USER,
          pass: SMTP_PASS
        } : void 0
      });
    }
    return this.transporter;
  }
  createAddressLink(address) {
    const encodedAddress = encodeURIComponent(address);
    return `<a href="https://maps.google.com/maps?q=${encodedAddress}" target="_blank" style="color: #667eea; text-decoration: none;">${address}</a>`;
  }
  getFormTypeIcon(formType) {
    return formType === "offerte" ? "\u{1F4CB}" : "\u{1F4AC}";
  }
  getFormTypeName(formType) {
    return formType === "offerte" ? "Offerte Aanvraag" : "Service Aanvraag";
  }
  /**
   * Stuur e-mail met attachments (uploads).
   */
  async sendEmailWithAttachments(opts) {
    const {
      subject,
      html,
      text: text2,
      files = [],
      to = MAIL_TO,
      from = MAIL_FROM,
      contactData
    } = opts;
    if (!subject || !html) {
      throw new Error("emailservice: subject en html zijn verplicht.");
    }
    if (!to) throw new Error("emailservice: MAIL_TO ontbreekt (env of opts).");
    if (!from) throw new Error("emailservice: MAIL_FROM ontbreekt (env of opts).");
    const perFileLimit = toBytes(MAX_PER_FILE_MB);
    const totalLimit = toBytes(MAX_TOTAL_SIZE_MB);
    let total = 0;
    const attachments = [];
    if (contactData && (contactData.firstName || contactData.email)) {
      try {
        const vcardData = {
          firstName: contactData.firstName,
          lastName: contactData.lastName,
          email: contactData.email,
          phone: contactData.phone,
          address: contactData.address,
          projectDescription: contactData.projectDescription,
          selectedService: contactData.selectedService,
          // Add individual components if available
          street: contactData.street,
          houseNumber: contactData.houseNumber,
          city: contactData.city,
          postcode: contactData.postcode,
          country: contactData.country
        };
        const vcardBuffer = createTBGSVCard(vcardData);
        let filenameParts = [];
        if (contactData.firstName || contactData.lastName) {
          filenameParts.push([contactData.firstName, contactData.lastName].filter(Boolean).join("_"));
        }
        if (contactData.street && contactData.houseNumber) {
          filenameParts.push(`${contactData.street}_${contactData.houseNumber}`.replace(/[^a-zA-Z0-9_]/g, "_"));
          if (contactData.postcode) {
            filenameParts.push(contactData.postcode.replace(/\s/g, ""));
          }
        } else if (contactData.address) {
          const addressParts = contactData.address.split(",")[0].trim();
          const cleanAddress = addressParts.replace(/[^a-zA-Z0-9\s]/g, "").replace(/\s+/g, "_");
          if (cleanAddress) {
            filenameParts.push(cleanAddress);
          }
          const postcodeMatch = contactData.address.match(/(\d{4}\s*[A-Za-z]{2})/);
          if (postcodeMatch) {
            filenameParts.push(postcodeMatch[1].replace(/\s/g, ""));
          }
        }
        const filename = filenameParts.length > 0 ? `${filenameParts.join("_").toLowerCase().replace(/[^a-z0-9_]/g, "")}_tbgs.vcf` : "tbgs_contact.vcf";
        attachments.push({
          filename,
          contentType: "text/vcard; charset=utf-8",
          content: vcardBuffer
        });
        console.log(`\u2713 TBGS vCard toegevoegd als eerste attachment: ${filename}`);
      } catch (vcardError) {
        console.warn("vCard generatie gefaald:", vcardError);
      }
    }
    for (const f of files) {
      const name = hashName(f.originalname || f.filename || "upload.bin");
      const mimetype = f.mimetype || "application/octet-stream";
      const size = typeof f.size === "number" ? f.size : f.path && fs2.existsSync(f.path) ? fs2.statSync(f.path).size : 0;
      if (!isAllowedFile(f.originalname || f.path || name, mimetype)) {
        console.warn(`emailservice: blocked/unknown file type: ${f.originalname || f.path}`);
        continue;
      }
      if (size > perFileLimit) {
        console.warn(`emailservice: file te groot (${size} > ${perFileLimit}): ${f.originalname}`);
        continue;
      }
      if (total + size > totalLimit) {
        console.warn(`emailservice: total attachment limiet bereikt. Skip: ${f.originalname}`);
        continue;
      }
      if (f.path && fs2.existsSync(f.path)) {
        attachments.push({
          filename: name,
          contentType: mimetype,
          content: fs2.createReadStream(f.path)
        });
      } else if (f.buffer) {
        attachments.push({
          filename: name,
          contentType: mimetype,
          content: Buffer.isBuffer(f.buffer) ? f.buffer : Buffer.from(f.buffer)
        });
      } else {
        console.warn(`emailservice: onbekend file input, skip: ${f.originalname || "unnamed"}`);
        continue;
      }
      total += size;
    }
    const transporter = await this.getTransporter();
    const mailOptions = {
      from,
      to,
      subject,
      text: text2 || html.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim().slice(0, 1e3),
      html,
      // Clean HTML without metadata
      attachments
    };
    const info = await withRetries(() => transporter.sendMail(mailOptions), { retries: 3, baseDelayMs: 750 });
    return info;
  }
  async sendNotificationEmail(data) {
    try {
      const formIcon = this.getFormTypeIcon(data.formType);
      const formTypeName = this.getFormTypeName(data.formType);
      const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Nieuwe ${formTypeName}</title>
          </head>
          <body style="margin: 0; padding: 20px; font-family: Arial, sans-serif; background-color: #f5f5f5;">
            <div style="max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              
              <h1 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">
                ${formIcon} Nieuwe ${formTypeName}
              </h1>
              
              <p style="color: #666; margin-bottom: 30px;">
                Ontvangen op ${data.submittedAt.toLocaleDateString("nl-NL")} om ${data.submittedAt.toLocaleTimeString("nl-NL", { hour: "2-digit", minute: "2-digit" })}
              </p>
              
              <div style="margin-bottom: 25px;">
                <h3 style="color: #333; margin-bottom: 15px;">Klantgegevens</h3>
                <table style="width: 100%; border-collapse: collapse;">
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold; width: 120px;">Naam:</td>
                    <td style="padding: 8px 0;">${data.firstName} ${data.lastName}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold;">Adres:</td>
                    <td style="padding: 8px 0;"><a href="https://maps.google.com/maps?q=${encodeURIComponent(data.address)}" target="_blank" style="color: #0066cc; text-decoration: none;">${data.address}</a></td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold;">Email:</td>
                    <td style="padding: 8px 0;"><a href="mailto:${data.email}" style="color: #0066cc; text-decoration: none;">${data.email}</a></td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold;">Telefoon:</td>
                    <td style="padding: 8px 0;"><a href="tel:${data.phone}" style="color: #0066cc; text-decoration: none;">${data.phone}</a></td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold;">Contact voorkeur:</td>
                    <td style="padding: 8px 0;">${data.contactPreference}</td>
                  </tr>
                </table>
              </div>
              
              <div style="margin-bottom: 25px;">
                <h3 style="color: #333; margin-bottom: 15px;">Project Details</h3>
                <table style="width: 100%; border-collapse: collapse;">
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold; width: 120px;">Service:</td>
                    <td style="padding: 8px 0;">${data.selectedService}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0; font-weight: bold; vertical-align: top;">Beschrijving:</td>
                    <td style="padding: 8px 0; line-height: 1.5;">${data.projectDescription}</td>
                  </tr>
                </table>
              </div>
              
              <div style="margin-top: 30px; text-align: center; color: #666; font-size: 14px; border-top: 1px solid #eee; padding-top: 20px;">
                <strong>TBGS B.V.</strong><br>
                Totaal Bouw Groep Specialisten
              </div>
            </div>
          </body>
          </html>
      `;
      await this.sendEmailWithAttachments({
        subject: `${formIcon} Nieuwe ${formTypeName}: ${data.selectedService} - ${data.firstName} ${data.lastName}`,
        html,
        files: data.files || [],
        contactData: {
          firstName: data.firstName,
          lastName: data.lastName,
          email: data.email,
          phone: data.phone,
          address: data.address,
          projectDescription: data.projectDescription,
          selectedService: data.selectedService
        }
      });
      console.log("Notification email sent successfully");
    } catch (error) {
      console.error("Error sending notification email:", error);
      throw error;
    }
  }
  async sendThankYouEmail(data) {
    try {
      const transporter = await this.getTransporter();
      const formTypeName = this.getFormTypeName(data.formType);
      const addressLink = this.createAddressLink(data.address);
      let logoAttachment = null;
      try {
        const fs5 = await import("fs");
        const pathLib = await import("path");
        const tbgsLogoPath = pathLib.join(process.cwd(), "attached_assets", "TBGS 545x642_1754928031668.png");
        if (fs5.existsSync(tbgsLogoPath)) {
          logoAttachment = {
            filename: "tbgs-logo.png",
            path: tbgsLogoPath,
            cid: "tbgs-logo",
            contentDisposition: "inline"
          };
          console.log("\u2713 TBGS logo loaded for email:", tbgsLogoPath);
        } else {
          console.warn("TBGS logo file not found:", tbgsLogoPath);
        }
      } catch (error) {
        console.warn("Could not load TBGS logo for email:", error);
      }
      const mailOptions = {
        from: process.env.GMAIL_USER,
        to: data.email,
        subject: `Bedankt ${data.firstName}! Je ${formTypeName.toLowerCase()} is ontvangen - TBGS B.V.`,
        attachments: logoAttachment ? [logoAttachment] : [],
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Bedankt voor je aanvraag</title>
          </head>
          <body style="margin: 0; padding: 0; background-color: #f4f4f4;">
            <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 650px; margin: 20px auto; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
              
              <!-- Header with TBGS Branding -->
              <div style="background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); padding: 30px 20px; text-align: center;">
                <div style="margin-bottom: 20px;">
                  <img src="cid:tbgs-logo" alt="TBGS Logo" style="max-width: 120px; height: auto;">
                </div>
                <h1 style="color: white; margin: 0; font-size: 28px; font-weight: 300;">
                  Bedankt ${data.firstName}!
                </h1>
                <p style="color: rgba(255,255,255,0.9); margin: 8px 0 0 0; font-size: 16px;">
                  Je aanvraag is succesvol ontvangen
                </p>
              </div>
              
              <!-- Content -->
              <div style="padding: 30px;">
                
                <!-- Simple confirmation -->
                <div style="text-align: center; margin-bottom: 30px;">
                  <p style="color: #2c3e50; font-size: 18px; line-height: 1.6; margin: 0;">
                    We hebben je aanvraag voor <strong>${data.selectedService}</strong> ontvangen.<br>
                    Een van onze specialisten neemt binnen 24 uur contact met je op.
                  </p>
                </div>

                ${data.selectedService.toLowerCase().includes("storm") || data.selectedService.toLowerCase().includes("lekkage") ? `
                <div style="background: #ff6b6b; color: white; padding: 20px; border-radius: 10px; margin-bottom: 25px; text-align: center;">
                  <h3 style="margin: 0 0 10px 0; font-size: 16px;">Spoedgeval</h3>
                  <p style="margin: 0; font-size: 14px;">
                    We begrijpen dat dit urgent kan zijn. Onze specialist neemt zo snel mogelijk contact op.
                  </p>
                </div>
                ` : ""}

                <!-- Contact Information -->
                <div style="background: #2c3e50; color: white; padding: 25px; border-radius: 10px; text-align: center; margin-bottom: 25px;">
                  <h3 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600;">Vragen of spoedeisend?</h3>
                  <div style="display: grid; gap: 12px; max-width: 320px; margin: 0 auto;">
                    <a href="https://wa.me/31614595142?text=Hallo%20Team%20TBGS%2C%20ik%20heb%20een%20aanvraag%20ingediend%20via%20de%20website%20en%20zou%20graag%20meer%20informatie%20ontvangen.%20Er%20zit%20wat%20haast%20bij." style="background: #2ecc71; color: white; padding: 14px 18px; border-radius: 8px; text-decoration: none; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 16px; text-align: center; transition: background-color 0.3s;">
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; flex-shrink: 0;">
                        <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.893 3.386"/>
                      </svg>
                      <span style="text-align: center;">WhatsApp Direct</span>
                    </a>
                    <a href="mailto:info@tbgs.nl" style="background: #34495e; color: white; padding: 14px 18px; border-radius: 8px; text-decoration: none; display: flex; align-items: center; justify-content: center; font-weight: 500; font-size: 16px; text-align: center; transition: background-color 0.3s;">
                      <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; flex-shrink: 0;">
                        <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.89 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
                      </svg>
                      <span style="text-align: center;">info@tbgs.nl</span>
                    </a>
                  </div>
                </div>
              </div>
              
              <!-- Footer -->
              <div style="background: #2c3e50; color: white; padding: 25px; text-align: center;">
                <h3 style="margin: 0 0 8px 0; font-size: 20px;">TBGS B.V.</h3>
                <p style="margin: 0 0 5px 0; font-size: 16px; opacity: 0.9;">Totaal Bouw Groep Specialisten</p>
                <p style="margin: 0; font-size: 13px; opacity: 0.7;">Samen duurzaam & innovatief (ver)bouwen</p>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                  <p style="margin: 0; font-size: 12px; opacity: 0.6;">
                    Deze email is verstuurd omdat je een aanvraag hebt ingediend op onze website.
                  </p>
                </div>
              </div>
            </div>
          </body>
          </html>
        `
      };
      await transporter.sendMail(mailOptions);
      console.log("Thank you email sent successfully");
    } catch (error) {
      console.error("Error sending thank you email:", error);
      throw error;
    }
  }
};
var emailService = new EmailService();

// server/routes.ts
import multer from "multer";
import fs3 from "fs";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
var contactFormSchema = z.object({
  firstName: z.string().min(1, "Voornaam is verplicht"),
  lastName: z.string().min(1, "Achternaam is verplicht"),
  email: z.string().email("Ongeldig e-mailadres"),
  phone: z.string().min(1, "Telefoonnummer is verplicht"),
  location: z.string().min(1, "Locatie is verplicht"),
  serviceType: z.string().min(1, "Type werkzaamheden is verplicht"),
  description: z.string().optional(),
  privacy: z.boolean().refine((val) => val === true, "Akkoord met privacyverklaring is verplicht")
});
var offerteFormSchema = z.object({
  voornaam: z.string().min(2, "Voornaam moet minimaal 2 karakters zijn"),
  achternaam: z.string().min(2, "Achternaam moet minimaal 2 karakters zijn"),
  email: z.string().email("Voer een geldig e-mailadres in"),
  telefoon: z.string().min(10, "Voer een geldig telefoonnummer in"),
  adres: z.string().min(5, "Voer uw volledige adres in"),
  postcode: z.string().min(6, "Voer een geldige postcode in"),
  plaats: z.string().min(2, "Voer uw woonplaats in"),
  specialisme: z.string().min(1, "Kies een specialisme"),
  projectType: z.string().min(1, "Kies een projecttype"),
  tijdlijn: z.string().min(1, "Kies de gewenste tijdlijn"),
  budget: z.string().optional(),
  beschrijving: z.string().min(20, "Beschrijf uw project in minimaal 20 karakters"),
  contactVoorkeur: z.string().min(1, "Kies uw contactvoorkeur"),
  privacyAkkoord: z.boolean().refine((val) => val === true, "U moet akkoord gaan met de privacyverklaring"),
  nieuwsbrief: z.boolean().optional()
});
var adminLoginSchema = z.object({
  email: z.string().email("Ongeldig e-mailadres"),
  password: z.string().min(6, "Wachtwoord moet minimaal 6 karakters zijn")
});
var adminCreateSchema = insertAdminUserSchema.extend({
  password: z.string().min(6, "Wachtwoord moet minimaal 6 karakters zijn")
});
var JWT_SECRET = process.env.JWT_SECRET || "your-secret-key-change-this-in-production";
var requireAdminAuth = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    if (!token) {
      return res.status(401).json({ error: "Geen authenticatie token" });
    }
    const decoded = jwt.verify(token, JWT_SECRET);
    const adminUser = await storage.getAdminUser(decoded.userId);
    if (!adminUser) {
      return res.status(401).json({ error: "Ongeldige token" });
    }
    req.adminUser = adminUser;
    next();
  } catch (error) {
    return res.status(401).json({ error: "Ongeldige token" });
  }
};
var generateSlug = (title) => {
  return title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
};
var normalizeFileName = (originalName) => {
  return originalName.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9.-]/g, "").replace(/--+/g, "-").replace(/^-|-$/g, "");
};
var upload = multer({
  dest: "tmp/uploads",
  limits: {
    fileSize: 12 * 1024 * 1024,
    // 12MB per file
    files: 8
  },
  fileFilter: (req, file, cb) => {
    const ok = /^(image\/(jpe?g|png|gif|webp)|application\/pdf|text\/plain|application\/(msword|vnd.openxmlformats-officedocument\.(wordprocessingml\.document|spreadsheetml\.sheet)))/i.test(file.mimetype);
    if (ok) {
      file.originalname = normalizeFileName(file.originalname);
    }
    cb(null, ok);
  }
});
async function registerRoutes(app2) {
  app2.get("/api/google-maps-key", (req, res) => {
    res.json({ apiKey: process.env.GOOGLE_MAPS_API_KEY || "" });
  });
  app2.post("/api/service-request", upload.array("files", 8), async (req, res) => {
    try {
      const validatedData = insertServiceRequestSchema.parse(req.body);
      const photosArray = validatedData.photos ? Array.from(validatedData.photos).map(String) : [];
      const [savedRequest] = await db.insert(serviceRequests).values({
        ...validatedData,
        photos: photosArray
      }).returning();
      const uploadedFiles = req.files || [];
      if (uploadedFiles.length > 0) {
        console.log(`\u2713 ${uploadedFiles.length} bestanden ontvangen voor aanvraag ${savedRequest.id}:`);
        uploadedFiles.forEach((file, index) => {
          console.log(`  ${index + 1}. ${file.originalname} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
        });
      }
      try {
        await emailService.sendNotificationEmail({
          ...validatedData,
          photos: photosArray,
          submittedAt: savedRequest.submittedAt || /* @__PURE__ */ new Date(),
          formType: "popup",
          files: uploadedFiles
        });
        console.log(`\u2713 Notification email sent voor aanvraag ${savedRequest.id} met ${uploadedFiles.length} attachments`);
      } catch (emailError) {
        console.error("Failed to send notification email:", emailError);
      }
      try {
        await emailService.sendThankYouEmail({
          ...validatedData,
          photos: photosArray,
          submittedAt: savedRequest.submittedAt || /* @__PURE__ */ new Date(),
          formType: "popup"
        });
      } catch (emailError) {
        console.error("Failed to send thank you email:", emailError);
      }
      res.status(200).json({
        success: true,
        message: "Uw aanvraag is succesvol verzonden. Wij nemen binnen 24 uur contact met u op.",
        id: savedRequest.id
      });
    } catch (error) {
      console.error("Service request error:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          message: "Controleer uw gegevens en probeer opnieuw.",
          errors: error.errors
        });
      }
      res.status(500).json({
        success: false,
        message: "Er is een fout opgetreden. Probeer het later opnieuw."
      });
    } finally {
      for (const f of req.files || []) {
        try {
          fs3.unlinkSync(f.path);
        } catch {
        }
      }
    }
  });
  app2.post("/api/contact", upload.array("files", 8), async (req, res) => {
    try {
      const validatedData = contactFormSchema.parse(req.body);
      const emailData = {
        firstName: validatedData.firstName,
        lastName: validatedData.lastName,
        email: validatedData.email,
        phone: validatedData.phone,
        selectedService: validatedData.serviceType,
        address: validatedData.location,
        projectDescription: validatedData.description || "Geen beschrijving opgegeven",
        contactPreference: "E-mail",
        // default for contact form
        photos: [],
        submittedAt: /* @__PURE__ */ new Date(),
        formType: "popup",
        files: req.files || []
      };
      try {
        await emailService.sendNotificationEmail(emailData);
      } catch (emailError) {
        console.error("Failed to send notification email:", emailError);
      }
      try {
        await emailService.sendThankYouEmail(emailData);
      } catch (emailError) {
        console.error("Failed to send thank you email:", emailError);
      }
      res.status(200).json({
        success: true,
        message: "Uw aanvraag is succesvol verzonden. Wij nemen binnen 24 uur contact met u op."
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "Controleer uw invoer en probeer opnieuw.",
          errors: error.errors.map((err) => ({
            field: err.path.join("."),
            message: err.message
          }))
        });
      } else {
        console.error("Contact form error:", error);
        res.status(500).json({
          success: false,
          message: "Er is een fout opgetreden bij het versturen van uw bericht. Probeer het opnieuw of neem telefonisch contact op."
        });
      }
    } finally {
      for (const f of req.files || []) {
        try {
          fs3.unlinkSync(f.path);
        } catch {
        }
      }
    }
  });
  app2.post("/api/offerte", upload.array("files", 8), async (req, res) => {
    try {
      const validatedData = offerteFormSchema.parse(req.body);
      const emailData = {
        firstName: validatedData.voornaam,
        lastName: validatedData.achternaam,
        email: validatedData.email,
        phone: validatedData.telefoon,
        selectedService: `${validatedData.specialisme} - ${validatedData.projectType}`,
        address: `${validatedData.adres}, ${validatedData.postcode} ${validatedData.plaats}`,
        projectDescription: `${validatedData.beschrijving}

Project details:
- Tijdlijn: ${validatedData.tijdlijn}
- Budget: ${validatedData.budget || "Niet opgegeven"}`,
        contactPreference: validatedData.contactVoorkeur,
        photos: [],
        submittedAt: /* @__PURE__ */ new Date(),
        formType: "offerte",
        files: req.files || []
      };
      try {
        await emailService.sendNotificationEmail(emailData);
      } catch (emailError) {
        console.error("Failed to send offerte notification email:", emailError);
      }
      try {
        await emailService.sendThankYouEmail(emailData);
      } catch (emailError) {
        console.error("Failed to send offerte thank you email:", emailError);
      }
      res.status(200).json({
        success: true,
        message: "Uw offerte aanvraag is succesvol verzonden. Wij nemen binnen 24 uur contact met u op voor een afspraak."
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "Controleer uw invoer en probeer opnieuw.",
          errors: error.errors.map((err) => ({
            field: err.path.join("."),
            message: err.message
          }))
        });
      } else {
        console.error("Offerte form error:", error);
        res.status(500).json({
          success: false,
          message: "Er is een fout opgetreden bij het versturen van uw offerte aanvraag. Probeer het opnieuw of neem telefonisch contact op."
        });
      }
    } finally {
      for (const f of req.files || []) {
        try {
          fs3.unlinkSync(f.path);
        } catch {
        }
      }
    }
  });
  app2.get("/api/health", (req, res) => {
    res.status(200).json({
      status: "healthy",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      service: "TBGS Contact API"
    });
  });
  app2.get("/api/service-areas", (req, res) => {
    const serviceAreas = {
      netherlands: [
        { name: "Eindhoven", lat: 51.4416, lng: 5.4697 },
        { name: "Nuenen", lat: 51.4703, lng: 5.5531 },
        { name: "Veldhoven", lat: 51.42, lng: 5.4047 },
        { name: "Best", lat: 51.5067, lng: 5.39 },
        { name: "Geldrop", lat: 51.4217, lng: 5.5597 },
        { name: "Son en Breugel", lat: 51.515, lng: 5.495 },
        { name: "Valkenswaard", lat: 51.35, lng: 5.45 }
      ],
      belgium: [
        { name: "Hamont-Achel", lat: 51.25, lng: 5.3167 },
        { name: "Lommel", lat: 51.2308, lng: 5.3119 },
        { name: "Pelt", lat: 51.2167, lng: 5.4167 }
      ]
    };
    res.status(200).json(serviceAreas);
  });
  app2.post("/api/objects/upload", async (req, res) => {
    try {
      const objectStorageService = new ObjectStorageService();
      const { batch = false, count = 1 } = req.body;
      if (batch && count > 1) {
        const uploadURLs = await objectStorageService.getBatchUploadURLs(count);
        res.json({ uploadURLs, batch: true });
      } else {
        const uploadURL = await objectStorageService.getObjectEntityUploadURL();
        res.json({ uploadURL });
      }
    } catch (error) {
      console.error("Error getting upload URL:", error);
      res.status(500).json({ error: "Failed to get upload URL" });
    }
  });
  app2.get("/public-objects/:filePath(*)", async (req, res) => {
    const filePath = req.params.filePath;
    const objectStorageService = new ObjectStorageService();
    try {
      const file = await objectStorageService.searchPublicObject(filePath);
      if (!file) {
        return res.status(404).json({ error: "File not found" });
      }
      objectStorageService.downloadObject(file, res);
    } catch (error) {
      console.error("Error searching for public object:", error);
      return res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.get("/objects/:objectPath(*)", async (req, res) => {
    const objectStorageService = new ObjectStorageService();
    try {
      const objectFile = await objectStorageService.getObjectEntityFile(req.path);
      objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      console.error("Error accessing object:", error);
      if (error instanceof ObjectNotFoundError) {
        return res.sendStatus(404);
      }
      return res.sendStatus(500);
    }
  });
  app2.get("/api/google-business/:placeId", async (req, res) => {
    const { placeId } = req.params;
    const apiKey = process.env.GOOGLE_PLACES_API_KEY;
    if (!apiKey) {
      return res.status(500).json({ error: "Google Places API key not configured" });
    }
    try {
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=name,rating,reviews,formatted_address,formatted_phone_number,website,opening_hours,geometry,photos,user_ratings_total&key=${apiKey}`
      );
      if (!response.ok) {
        throw new Error(`Google Places API error: ${response.status}`);
      }
      const data = await response.json();
      if (data.status !== "OK") {
        console.error("Google Places API status:", data.status, data.error_message);
        throw new Error(`Google Places API status: ${data.status}`);
      }
      res.json(data.result);
    } catch (error) {
      console.error("Error fetching Google Business data:", error);
      const tbgsData = {
        place_id: placeId,
        name: "TBGS BV - Totaal Bouw Groep Specialisten",
        formatted_address: "Hurksestraat 64, 5652 AL Eindhoven, Nederland",
        formatted_phone_number: "+31 40 202 6744",
        website: "https://www.tbgs.nl",
        rating: 4.9,
        user_ratings_total: 127,
        opening_hours: {
          open_now: true,
          weekday_text: [
            "Maandag: 08:00\u201317:00",
            "Dinsdag: 08:00\u201317:00",
            "Woensdag: 08:00\u201317:00",
            "Donderdag: 08:00\u201317:00",
            "Vrijdag: 08:00\u201317:00",
            "Zaterdag: 09:00\u201316:00",
            "Zondag: Gesloten"
          ]
        },
        geometry: {
          location: {
            lat: 51.4416,
            // Eindhoven coordinates
            lng: 5.4697
          }
        },
        reviews: [
          {
            author_name: "Marco van den Berg",
            rating: 5,
            relative_time_description: "3 weken geleden",
            text: "Uitstekende service van TBGS! Ons dak werd professioneel gerepareerd, binnen budget en op tijd. Zeer tevreden met de kwaliteit en communicatie.",
            time: 1703875200,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocKxVxvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          },
          {
            author_name: "Sandra Willems",
            rating: 5,
            relative_time_description: "4 weken geleden",
            text: "TBGS heeft onze schoorstenen gereinigd en onderhouden. Zeer vakkundige medewerkers en faire prijzen. Zeker een aanrader voor dakwerk!",
            time: 1703788800,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocKyVxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          },
          {
            author_name: "Robert de Jong",
            rating: 5,
            relative_time_description: "1 maand geleden",
            text: "Complete dakrenovatie door TBGS uitgevoerd. Van offerte tot oplevering alles perfect geregeld. Goede communicatie en vakmanschap!",
            time: 1703702400,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocKzVxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          },
          {
            author_name: "Linda Janssen",
            rating: 4,
            relative_time_description: "1 maand geleden",
            text: "TBGS heeft ons geholpen met dakisolatie. Professioneel team en goede service. Kleine vertraging door weer, maar eindresultaat is prima.",
            time: 1703616e3,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocK0Vxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          },
          {
            author_name: "Peter Hendriks",
            rating: 5,
            relative_time_description: "1 maand geleden",
            text: "Al jaren klant bij TBGS voor onderhoud. Betrouwbaar bedrijf met eerlijke prijzen. Laatste dakgoten vervangen en weer keurig werk geleverd!",
            time: 1703529600,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocK1Vxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          },
          {
            author_name: "Erik van der Meer",
            rating: 5,
            relative_time_description: "2 maanden geleden",
            text: "Snelle en effici\xEBnte dakreparatie na stormschade. TBGS was er snel bij en heeft alles vakkundig opgelost. Zeer tevreden klant!",
            time: 1701110400,
            profile_photo_url: "https://lh3.googleusercontent.com/a/ACg8ocK2Vxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          }
        ]
      };
      res.json(tbgsData);
    }
  });
  app2.post("/api/admin/login", async (req, res) => {
    try {
      const { email, password } = adminLoginSchema.parse(req.body);
      const adminUser = await storage.getAdminUserByEmail(email);
      if (!adminUser) {
        return res.status(401).json({ error: "Ongeldige inloggegevens" });
      }
      const passwordValid = await bcrypt.compare(password, adminUser.password);
      if (!passwordValid) {
        return res.status(401).json({ error: "Ongeldige inloggegevens" });
      }
      const token = jwt.sign({ userId: adminUser.id }, JWT_SECRET, { expiresIn: "7d" });
      res.json({
        token,
        user: {
          id: adminUser.id,
          email: adminUser.email,
          name: adminUser.name,
          role: adminUser.role
        }
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(400).json({ error: "Login mislukt" });
    }
  });
  app2.post("/api/admin/setup", async (req, res) => {
    try {
      const existingAdmins = await storage.getAdminUser("any");
      const { email, password, name } = adminCreateSchema.parse(req.body);
      const hashedPassword = await bcrypt.hash(password, 12);
      const adminUser = await storage.createAdminUser({
        email,
        password: hashedPassword,
        name,
        role: "admin"
      });
      res.json({
        message: "Admin gebruiker aangemaakt",
        user: {
          id: adminUser.id,
          email: adminUser.email,
          name: adminUser.name
        }
      });
    } catch (error) {
      console.error("Admin setup error:", error);
      res.status(400).json({ error: "Setup mislukt" });
    }
  });
  app2.get("/api/admin/me", requireAdminAuth, (req, res) => {
    res.json({
      id: req.adminUser.id,
      email: req.adminUser.email,
      name: req.adminUser.name,
      role: req.adminUser.role
    });
  });
  app2.get("/api/admin/categories", requireAdminAuth, async (req, res) => {
    try {
      const categories2 = await storage.getCategories();
      res.json(categories2);
    } catch (error) {
      console.error("Get categories error:", error);
      res.status(500).json({ error: "Categorie\xEBn ophalen mislukt" });
    }
  });
  app2.post("/api/admin/categories", requireAdminAuth, async (req, res) => {
    try {
      const data = insertCategorySchema.parse(req.body);
      if (!data.slug) {
        data.slug = generateSlug(data.name);
      }
      const category = await storage.createCategory(data);
      res.json(category);
    } catch (error) {
      console.error("Create category error:", error);
      res.status(400).json({ error: "Categorie aanmaken mislukt" });
    }
  });
  app2.put("/api/admin/categories/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertCategorySchema.partial().parse(req.body);
      const category = await storage.updateCategory(id, data);
      if (!category) {
        return res.status(404).json({ error: "Categorie niet gevonden" });
      }
      res.json(category);
    } catch (error) {
      console.error("Update category error:", error);
      res.status(400).json({ error: "Categorie bijwerken mislukt" });
    }
  });
  app2.delete("/api/admin/categories/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteCategory(id);
      if (!deleted) {
        return res.status(404).json({ error: "Categorie niet gevonden" });
      }
      res.json({ message: "Categorie verwijderd" });
    } catch (error) {
      console.error("Delete category error:", error);
      res.status(400).json({ error: "Categorie verwijderen mislukt" });
    }
  });
  app2.get("/api/admin/tags", requireAdminAuth, async (req, res) => {
    try {
      const tags2 = await storage.getTags();
      res.json(tags2);
    } catch (error) {
      console.error("Get tags error:", error);
      res.status(500).json({ error: "Tags ophalen mislukt" });
    }
  });
  app2.post("/api/admin/tags", requireAdminAuth, async (req, res) => {
    try {
      const data = insertTagSchema.parse(req.body);
      if (!data.slug) {
        data.slug = generateSlug(data.name);
      }
      const tag = await storage.createTag(data);
      res.json(tag);
    } catch (error) {
      console.error("Create tag error:", error);
      res.status(400).json({ error: "Tag aanmaken mislukt" });
    }
  });
  app2.put("/api/admin/tags/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertTagSchema.partial().parse(req.body);
      const tag = await storage.updateTag(id, data);
      if (!tag) {
        return res.status(404).json({ error: "Tag niet gevonden" });
      }
      res.json(tag);
    } catch (error) {
      console.error("Update tag error:", error);
      res.status(400).json({ error: "Tag bijwerken mislukt" });
    }
  });
  app2.delete("/api/admin/tags/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteTag(id);
      if (!deleted) {
        return res.status(404).json({ error: "Tag niet gevonden" });
      }
      res.json({ message: "Tag verwijderd" });
    } catch (error) {
      console.error("Delete tag error:", error);
      res.status(400).json({ error: "Tag verwijderen mislukt" });
    }
  });
  app2.get("/api/admin/articles", requireAdminAuth, async (req, res) => {
    try {
      const { status, categoryId, search } = req.query;
      const filters = {
        status,
        categoryId,
        search
      };
      const articles2 = await storage.getArticles(filters);
      res.json(articles2);
    } catch (error) {
      console.error("Get articles error:", error);
      res.status(500).json({ error: "Artikelen ophalen mislukt" });
    }
  });
  app2.get("/api/articles", async (req, res) => {
    try {
      const articles2 = await storage.getPublishedArticles();
      res.json(articles2);
    } catch (error) {
      console.error("Get published articles error:", error);
      res.status(500).json({ error: "Artikelen ophalen mislukt" });
    }
  });
  app2.get("/api/admin/articles/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const article = await storage.getArticle(id);
      if (!article) {
        return res.status(404).json({ error: "Artikel niet gevonden" });
      }
      const tags2 = await storage.getArticleTags(id);
      res.json({ ...article, tags: tags2 });
    } catch (error) {
      console.error("Get article error:", error);
      res.status(500).json({ error: "Artikel ophalen mislukt" });
    }
  });
  app2.get("/api/articles/:slug", async (req, res) => {
    try {
      const { slug } = req.params;
      const article = await storage.getArticleBySlug(slug);
      if (!article || article.status !== "published") {
        return res.status(404).json({ error: "Artikel niet gevonden" });
      }
      const tags2 = await storage.getArticleTags(article.id);
      res.json({ ...article, tags: tags2 });
    } catch (error) {
      console.error("Get article by slug error:", error);
      res.status(500).json({ error: "Artikel ophalen mislukt" });
    }
  });
  app2.post("/api/admin/articles", requireAdminAuth, async (req, res) => {
    try {
      const data = insertArticleSchema.parse(req.body);
      if (!data.slug) {
        data.slug = generateSlug(data.title);
      }
      const existingArticle = await storage.getArticleBySlug(data.slug);
      if (existingArticle) {
        data.slug = `${data.slug}-${Date.now()}`;
      }
      const article = await storage.createArticle(data);
      if (req.body.tagIds && Array.isArray(req.body.tagIds)) {
        await storage.setArticleTags(article.id, req.body.tagIds);
      }
      res.json(article);
    } catch (error) {
      console.error("Create article error:", error);
      res.status(400).json({ error: "Artikel aanmaken mislukt" });
    }
  });
  app2.put("/api/admin/articles/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const data = insertArticleSchema.partial().parse(req.body);
      if (data.status === "published" && !data.publishedAt) {
        data.publishedAt = /* @__PURE__ */ new Date();
      }
      const article = await storage.updateArticle(id, data);
      if (!article) {
        return res.status(404).json({ error: "Artikel niet gevonden" });
      }
      if (req.body.tagIds && Array.isArray(req.body.tagIds)) {
        await storage.setArticleTags(id, req.body.tagIds);
      }
      res.json(article);
    } catch (error) {
      console.error("Update article error:", error);
      res.status(400).json({ error: "Artikel bijwerken mislukt" });
    }
  });
  app2.delete("/api/admin/articles/:id", requireAdminAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteArticle(id);
      if (!deleted) {
        return res.status(404).json({ error: "Artikel niet gevonden" });
      }
      res.json({ message: "Artikel verwijderd" });
    } catch (error) {
      console.error("Delete article error:", error);
      res.status(400).json({ error: "Artikel verwijderen mislukt" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs4 from "fs";
import path4 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path3 from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path3.resolve(import.meta.dirname, "client", "src"),
      "@shared": path3.resolve(import.meta.dirname, "shared"),
      "@assets": path3.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path3.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path3.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path4.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs4.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: true }));
async function startServer() {
  try {
    const server = await registerRoutes(app);
    await setupVite(app, server);
    const port = process.env.PORT || 5e3;
    server.listen(port, () => {
      log(`serving on port ${port}`);
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
}
startServer();